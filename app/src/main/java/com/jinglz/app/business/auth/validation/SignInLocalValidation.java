package com.jinglz.app.business.auth.validation;

import android.content.Context;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.text.TextUtils;
import android.util.Patterns;

import com.jinglz.app.R;
import com.jinglz.app.business.auth.AuthException;
import com.jinglz.app.data.repositories.LocationRepository;
import com.jinglz.app.ui.start.signin.models.SignInErrorModel;
import com.jinglz.app.ui.start.signin.models.SignInManualModel;

import java.util.Arrays;

import javax.inject.Inject;
import javax.inject.Singleton;

import rx.Single;

@Singleton
public class SignInLocalValidation {

    private final Context mContext;
    private final LocationRepository mLocationRepository;

    /**
     * Constructs new SignInLocalValidation with the specified context and locationRepository
     *
     * @param context variable of type Context
     * @param locationRepository LocationRepository variable used to initialize {@see #mLocationRepository}
     */
    @Inject
    public SignInLocalValidation(Context context, LocationRepository locationRepository) {
        mContext = context;
        mLocationRepository = locationRepository;
    }

    /**
     * method that validates {@link SignInManualModel}. validate manually for local data.
     * use {@link #localManualValidate(SignInManualModel)} for validation.
     *
     * @param signInModel SignInManualModel variable to validate
     * @return {@code Single.just(signInModel).flatMap(this::localManualValidate).map(validate -> signInModel)}
     */
    public Single<SignInManualModel> validateManualSignIn(@NonNull SignInManualModel signInModel) {
        return Single.just(signInModel)
                .flatMap(this::localManualValidate)
                .map(validate -> signInModel);
    }

    /**
     * method that validates token generated by social accounts. validate String token.
     * use {@link #localSocialValidate(String)} method for validation.
     * @param token String variable to be validated
     * @return {@code Single.just(token).flatMap(this::localSocialValidate).map(validate -> token)}
     */
    public Single<String> validateSocialSignIn(@NonNull String token) {
        return Single.just(token)
                .flatMap(this::localSocialValidate)
                .map(validate -> token);
    }

    /**
     * method that receives {@link SignInManualModel} as parameter, perform validations and return
     * {@code Single.just(true)} if valid. tests for mandatory fields by calling
     * {@link #missingFieldsValidate(SignInManualModel)}
     * and incorrect format of the fields by using {@link #incorrectFieldsValidate(SignInManualModel)}
     * {@code error} holds generated error in validation process
     *
     *
     * @param signInModel SignInManualModel variable used to validate
     * @return boolean variable true if credentials valid
     */
    private Single<Boolean> localManualValidate(@NonNull SignInManualModel signInModel) {
        SignInErrorModel error;

        error = missingFieldsValidate(signInModel);

        if (error == null) {
            error = incorrectFieldsValidate(signInModel);
        }

      /*  if (error == null) {
            error = incorrectCountry();
        }*/

        if (error != null) {
            return Single.error(new AuthException(error.description()));
        }
        return Single.just(true);
    }

    /**
     * method that receives String token as parameter, perform validations and return
     * {@code Single.just(true)} if valid.
     * tests for incorrect format of the fields by calling {@link #incorrectToken(String)}.
     *
     * @param token String variable to be validated
     * @return  {@code Single.just(true)} if token valid
     */
    private Single<Boolean> localSocialValidate(@NonNull String token) {

        SignInErrorModel error = incorrectCountry();

        if (error == null) {
            error = incorrectToken(token);
        }

        if (error != null) {
            return Single.error(new AuthException(error.description()));
        }

        return Single.just(true);
    }

    /**
     * method to check the empty fields.
     *
     * @param signInModel SignInManualModel variable to be validated
     * @return SignInErrorModel variable
     */
    @Nullable
    private SignInErrorModel missingFieldsValidate(@NonNull SignInManualModel signInModel) {
        if (signInModel.email().isEmpty() || signInModel.password().isEmpty()) {
            return SignInErrorModel.create(mContext.getString(R.string.error_field_missing));
        }
        return null;
    }

    /**
     * method to check {@code signInModel.email()} is valid or not
     *
     * @param signInModel SignInManualModel variable for validation. fetch email from {@code signInModel}
     * @return {@code SignInErrorModel.create(mContext.getString(R.string.error_sign_in_incorrect))}
     *         if pattern not matches. null otherwise.
     */
    @Nullable
    private SignInErrorModel incorrectFieldsValidate(@NonNull SignInManualModel signInModel) {
        if (!Patterns.EMAIL_ADDRESS.matcher(signInModel.email()).matches()) {
            return SignInErrorModel.create(mContext.getString(R.string.error_sign_in_incorrect));
        }
        return null;
    }

    /**
     * method checks if {@code token} is valid.
     * @param token String variable to be validated
     * @return {@code SignInErrorModel.create(mContext.getString(R.string.error_sign_in_incorrect))}
     *         {@code token} is valid,
     */
    @Nullable
    private SignInErrorModel incorrectToken(String token) {
        if (TextUtils.isEmpty(token)) {
            return SignInErrorModel.create(mContext.getString(R.string.error_sign_in_incorrect));
        }
        return null;
    }

    /**
     * method checks the {@code currentCountry} with array {@code countries}.
     *
     * @return {@code SignInErrorModel.create(mContext.getString(R.string.error_enable_location))} if
     *         {@code currentCountry} null, @code SignInErrorModel.create(mContext.getString(R.string.error_incorrect_location))} if
     *         {@code currentCountry} does not match with array {@code countries}, null otherwise.
     */
    @Nullable
    private SignInErrorModel incorrectCountry() {
        final String[] countries = mContext.getResources().getStringArray(R.array.supports_countries);
        final String currentCountry = mLocationRepository.getUserCountry().toBlocking().value();
        if (currentCountry == null) {
            return SignInErrorModel.create(mContext.getString(R.string.error_enable_location));
        } else if (!Arrays.asList(countries).contains(currentCountry)) {
            return SignInErrorModel.create(mContext.getString(R.string.error_incorrect_location));
        }
        return null;
    }

}
